<!-- #BeginTemplate "template.dwt" -->
        <!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- #BeginEditable "TITLE" -->
                <title>ByteString - Reference Documentation</title>
                    <!-- #EndEditable -->
<link rel=stylesheet type="text/css" href="style.css">
<meta name="author" content="Andreas Schwier">
</head>
<body>
<div align="left"><a href="http://www.cardcontact.de"><img src="banner.jpg" width="750" height="80" border="0"></a></div>
<div id="navigator">
    <p><b>Smart Card<br>Shell 3</b></p>
    <a href="index.html">Home</a><br><br>
    <a href="gperror.html">GPError</a><br>
    <a href="gpsystem.html">GPSystem</a><br>
    <a href="bytestring.html">ByteString</a><br>
    <a href="bytebuffer.html">ByteBuffer</a><br>
    <a href="tlv.html">TLV</a><br>
    <a href="tlvlist.html">TLVList</a><br>
    <a href="card.html">Card</a><br>
    <a href="atr.html">Atr</a><br>
    <a href="key.html">Key</a><br>
    <a href="crypto.html">Crypto</a><br>
    <a href="application.html">Application</a><br>
    <a href="gpapplication.html">GPApplication</a><br>
    <a href="gpsecuritydomain.html">GPSecDomain</a><br>
    <br>
    <a href="asn1.html">ASN1</a><br>
    <a href="cardfile.html">CardFile</a><br>
    <a href="isosecurechannel.html">IsoSecureChannel</a><br>
    <a href="applicationfactory.html">ApplFactory</a><br>
    <a href="gpxml.html">GPXML</a><br>
    <a href="jsscript.html">JsScript</a><br>
    <a href="cardsimulationadapter.html">CardSim</a><br>
    <br>
    <a href="x509.html">X509</a><br>
    <a href="crl.html">CRL</a><br>
    <a href="keystore.html">KeyStore</a><br>
    <a href="cmssigneddata.html">CMSSignedData</a><br>
    <a href="cmsgenerator.html">CMSGenerator</a><br>
    <a href="xmlsignature.html">XMLSignature</a><br>
    <a href="ocspquery.html">OCSPQuery</a><br>
    <a href="ldap.html">LDAP</a><br>
    <a href="soapconnection.html">SOAP</a><br>
    <a href="urlconnection.html">URLConnection</a><br>
    <br>
    <a href="pkcs11provider.html">PKCS11Provider</a><br>
    <a href="pkcs11session.html">PKCS11Session</a><br>
    <a href="pkcs11object.html">PKCS11Object</a><br>
    <br>
    <a href="outlinenode.html">OutlineNode</a><br>
    <a href="dialog.html">Dialog</a><br>
    <br>
    <a href="jsdoc/index.html">Tools</a><br>
    <br>
    <a href="http://www.openscdp.org">OpenSCDP</a><br>
</div>

<div id="main">
<!-- #BeginEditable "BODY" -->
                <h1>ByteString - Reference Documentation</h1>
<p>Implementation of an immutable binary string, similar to the String class.</p>
<h2>Index of Methods</h2>
<ul>
<li>
<a href="#Constructor">ByteString() constructor</a>
</li>
<li>
<a href="#and">and()</a>
</li>
<li>
<a href="#byteAt">byteAt()</a>
</li>
<li>
<a href="#bytes">bytes()</a>
</li>
<li>
<a href="#concat">concat()</a>
</li>
<li>
<a href="#crc">crc()</a>
</li>
<li>
<a href="#equals">equals()</a>
</li>
<li>
<a href="#find">find()</a>
</li>
<li>
<a href="#getL">getL()</a>
</li>
<li>
<a href="#getLV">getLV()</a>
</li>
<li>
<a href="#left">left()</a>
</li>
<li>
<a href="#neg">neg()</a>
</li>
<li>
<a href="#not">not()</a>
</li>
<li>
<a href="#or">or()</a>
</li>
<li>
<a href="#pad">pad()</a>
</li>
<li>
<a href="#right">right()</a>
</li>
<li>
<a href="#startsWith">startsWith()</a>
</li>
<li>
<a href="#toBase64">toBase64()</a>
</li>
<li>
<a href="#toBcd">toBcd()</a>
</li>
<li>
<a href="#toHex">toHex()</a>
</li>
<li>
<a href="#toSigned">toSigned()</a>
</li>
<li>
<a href="#toString">toString()</a>
</li>
<li>
<a href="#toUnsigned">toUnsigned()</a>
</li>
<li>
<a href="#xor">xor()</a>
</li>
<li>
<a href="#add">add()</a>
</li>
<li>
<a href="#valueOf">valueOf()</a>
</li>
</ul>
<h2>Constants</h2>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td>Number</td><td>XOR</td><td>Constant used in crc() method</td>
</tr>
</table>
<h2>Properties</h2>
<table class="content">
<colgroup>
<col width="100">
<col width="120">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td>Number</td><td>length</td><td>Number of bytes in the ByteString</td>
</tr>
</table>
<h2 id="Constructor">Constructor</h2>
<h3>Prototype</h3>
<p class="signature">ByteString(String stringValue, Number encoding)</p>
<h3>Description</h3>
            
<p>Create a ByteString object containing the data from stringValue decoded
               according to format defined in argument encoding</p>
            
<p>The following encoding formats can be used for the stringValue argument:</p>
            
<p>HEX - A string containing hexadecimal characters and arbitrary delimiters.</p>
            
<p>ASCII - A string containing ASCII characters and characters from Latin-1.</p>
            
<p>UTF8 - A string containing Unicode characters.</p>
            
<p>BASE64 - A string containing BASE-64 encoded data.</p>
            
<p>OID - A string containing an object identifier in dotted notation or
               separated by blanks (This is a proprietary extension to Global Platform Scripting).</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>String</code></td><td>stringValue</td><td>String containing the encoded binary data</td>
</tr>
<tr>
<td><code>Number</code></td><td>encoding</td><td>Encoding format. Must be one of HEX, ASCII, UTF8,
            BASE64 or OID</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments given</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments given</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ENCODING</td><td>The argument encoding contains an unknown encoding format</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_DATA</td><td>The argument stringValue contains characters not compatible with the encoding format</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>On or more arguments are not of the expected type</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("1234", HEX);

assert(x.length == 2);
assert(x.toString() == "12 34");


x = new ByteString("", HEX);

assert(x.length == 0);
assert(x.toString() == "");


x = new ByteString("0x1234 56.78.90+AB#cd'EF", HEX);

assert(x.length == 8);
assert(x.toString() == "12 34 56 78 90 AB CD EF");


x = new ByteString("1234ABCD&Auml;&Ouml;&Uuml;&szlig;", ASCII);

assert(x.length == 12);
assert(x.toString() == "31 32 33 34 41 42 43 44 C4 D6 DC DF");


x = new ByteString("1234ABCD&Auml;&Ouml;&Uuml;&szlig;", UTF8);

assert(x.length == 16);
assert(x.toString() == "31 32 33 34 41 42 43 44 C3 84 C3 96 C3 9C C3 9F");


x = new ByteString("SGVsbG8gV29ybGQ=", BASE64);

assert(x.length == 11);
assert(x.toString(ASCII) == "Hello World");


x = new ByteString("1.2.840.113549.1.1.2", OID);

assert(x.length == 9);
assert(x.toString(OID) == "1.2.840.113549.1.1.2");
assert(x.toString(HEX) == "2A864886F70D010102"); 


x = new ByteString("1 2 840 113549 1 1 2", OID);

assert(x.toString(HEX) == "2A864886F70D010102"); 


</pre>
<h2 id="and">and()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString and(ByteString value)</p>
<h3>Description</h3>The bitwise AND of the object for which this method is called and the argument.
            Both must be of equal size<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code><a href="bytestring.html">ByteString</a></code></td><td>value</td><td>ByteString object of same size to use in bitwise
            and operation</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>The result of the and operation as ByteString</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_LENGTH</td><td>Object and argument have different length</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("AA A5 55", HEX);
y = new ByteString("55 A5 AA", HEX);
z = x.and(y);
assert(z.toString(HEX) == "00A500", HEX);

</pre>
<h2 id="byteAt">byteAt()</h2>
<h3>Prototype</h3>
<p class="signature">Number byteAt(Number offset)</p>
<h3>Description</h3>Return the value of the byte at the zero based offset<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>offset</td><td>Zero based offset</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>Number</code></td><td>The value of the byte at offset</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_INDEX</td><td>Offset is out of range</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("123ABC&Auml;&Ouml;&Uuml;", ASCII);
assert(typeof(x.byteAt(0)) == "number");
assert(x.byteAt(0) == 0x31);
assert(x.byteAt(3) == 0x41);
assert(x.byteAt(6) == 0xC4);

</pre>
<h2 id="bytes">bytes()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString bytes(Number offset)</p>
<p class="signature">ByteString bytes(Number offset, Number count)</p>
<h3>Description</h3>Extract count bytes from a ByteString starting at zero based offset.
           If count is missing then the all remaining bytes from offset are extracted.<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>offset</td><td>Zero based offset from which bytes are extracted</td>
</tr>
<tr>
<td><code>Number</code></td><td>count</td><td>Number of bytes to extract</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>New ByteString containing the extracted bytes</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_INDEX</td><td>The offset is out of range</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_LENGTH</td><td>The offset plus the count exceeds the length of the buffer</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("123ABC&Auml;&Ouml;&Uuml;", ASCII);
y = x.bytes(3, 3);
assert(y.toString(ASCII) == "ABC");

y = x.bytes(6);
assert(y.toString(ASCII) == "&Auml;&Ouml;&Uuml;");

y = x.bytes(9);
assert(y.toString(ASCII) == "");

</pre>
<h2 id="concat">concat()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString concat(ByteString value)</p>
<h3>Description</h3>Concatenate ByteString for which the method is called with argument value and return a new ByteString object. 
           The ByteString for which the method is called is not changed.<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code><a href="bytestring.html">ByteString</a></code></td><td>value</td><td>ByteString to append to object for which the method is called</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>New ByteString object containing the concatenation of both objects</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("123", ASCII);
y = new ByteString("414243", HEX);

z = x.concat(y);

assert(z.toString(ASCII) == "123ABC");

z = z.concat(new ByteString("", HEX));

assert(z.toString(ASCII) == "123ABC");

</pre>
<h2 id="crc">crc()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString crc(Number method)</p>
<h3>Description</h3>Calculate a checksum for the ByteString object using the method defined by argument method<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>method</td><td>
<p>The method to use for checksum calculation.</p>
                       
<p>Currently only XOR is available, calculating the XOR checksum across all bytes in the ByteString</p>
</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code></code></td><td></td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_MECH</td><td>Argument method must be XOR</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("A55A", HEX);
c = x.crc(ByteString.XOR);
assert(c.toString(HEX) == "FF");

x = new ByteString("", HEX);
c = x.crc(ByteString.XOR);
assert(c.toString(HEX) == "00");

</pre>
<h2 id="equals">equals()</h2>
<h3>Prototype</h3>
<p class="signature">Boolean equals(ByteString value)</p>
<h3>Description</h3>Check if both ByteString have the same length and contain the same value.<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code><a href="bytestring.html">ByteString</a></code></td><td>value</td><td>ByteString object to check against</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>Boolean</code></td><td>true if both ByteString are equal, otherwise false</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("414243", HEX);
y = new ByteString("ABC", ASCII);

assert(x.equals(y));

y = new ByteString("CBA", ASCII);
assert(!x.equals(y));

y = new ByteString("ABCD", ASCII);
assert(!x.equals(y));

y = new ByteString("AB", ASCII);
assert(!x.equals(y));

</pre>
<h2 id="find">find()</h2>
<h3>Prototype</h3>
<p class="signature">Number find(ByteString value)</p>
<p class="signature">Number find(ByteString value, Number offset)</p>
<h3>Description</h3>Search the ByteString for the first occurance of the ByteString specified in argument value.
            Start at zero based offset or 0 if offset is not defined.<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code><a href="bytestring.html">ByteString</a></code></td><td>value</td><td>ByteString to search for</td>
</tr>
<tr>
<td><code>Number</code></td><td>offset</td><td>Zero based index to start search at. 0 is assumed if parameter is not present</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>Number</code></td><td>Zero based offset at which the search string was found or -1 if the search string
               could not be found</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_INDEX</td><td>Offset given in argument is out of range</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("ABCDABCD", ASCII);
y = new ByteString("BC", ASCII);

assert(typeof(x.find(y)) == "number");
assert(x.find(y) == 1);
assert(x.find(y, 2) == 5);
assert(x.find(y, -2) == 1);

y = new ByteString("CD", ASCII);
assert(x.find(y, 4) == 6);

y = new ByteString("CD", ASCII);
assert(x.find(y, 6) == 6);

y = new ByteString("CB", ASCII);
assert(x.find(y) == -1);

y = new ByteString("BCDE", ASCII);
assert(x.find(y) == -1);

y = new ByteString("", ASCII);
assert(x.find(y) == 0);

x = new ByteString("", ASCII);
y = new ByteString("", ASCII);
assert(x.find(y) == 0);
assert(x.find(y, 0) == 0);

</pre>
<h2 id="getL">getL()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString getL(Number method)</p>
<h3>Description</h3>
            
<p>Return a length field encoded as per specification in method.</p>
            
<p>TLV.EMV encodes the length field with a variable length as per
               ASN.1 DER encoding. Values in the range 0 to 127 are encoded in one byte.
               Values in the range 128 to 255 are encoded in two bytes with a leading '81'.
               Length fields in the range 256 to 65535 are encoded in three bytes with a
               leading '82' and two bytes in MSB/LSB order. Length fields in the range 65536
               to 16777215 are encoded in four bytes with a leading '83' and three bytes in 
               MSB/LSB format.</p>
			
<p>TLV.DGI encodes length values between 0 and 254 in one byte and length values
               between 255 and 65535 in three bytes with a leading 'FF' and two bytes in
               MSB/LSB format.</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>method</td><td>Must be either TLV.EMV or TLV.DGI.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>Length field as ByteString</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_LENGTH</td><td>Length must not exceed 65535 for DGI encoding</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_MECH</td><td>The encoding method is invalid</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("", ASCII);
y = x.getL(TLV.EMV);
assert(y.toString(HEX) == "00");

y = x.getL(TLV.DGI);
assert(y.toString(HEX) == "00");


x = new ByteString("123ABC", ASCII);
y = x.getL(TLV.EMV);
assert(y.toString(HEX) == "06");

y = x.getL(TLV.DGI);
assert(y.toString(HEX) == "06");


x = new ByteString("01234567890123456789012345678901234567890123456789012345" +
                   "67890123456789012345678901234567890123456789012345678901" +
                   "2345678901234567", ASCII);
y = x.getL(TLV.EMV);
assert(y.toString(HEX) == "8180");

y = x.getL(TLV.DGI);
assert(y.toString(HEX) == "80");


x = new ByteString("01234567890123456789012345678901234567890123456789012345" +
                   "67890123456789012345678901234567890123456789012345678901" +
                   "23456789012345678901234567890123456789012345678901234567" +
                   "89012345678901234567890123456789012345678901234567890123" +
                   "4567890123456789012345678901234", ASCII);
y = x.getL(TLV.EMV);
assert(y.toString(HEX) == "81FF");

y = x.getL(TLV.DGI);
assert(y.toString(HEX) == "FF00FF");


x = new ByteString("01234567890123456789012345678901234567890123456789012345" +
                   "67890123456789012345678901234567890123456789012345678901" +
                   "23456789012345678901234567890123456789012345678901234567" +
                   "89012345678901234567890123456789012345678901234567890123" +
                   "45678901234567890123456789012345", ASCII);
y = x.getL(TLV.EMV);
assert(y.toString(HEX) == "820100");

y = x.getL(TLV.DGI);
assert(y.toString(HEX) == "FF0100");

</pre>
<h2 id="getLV">getLV()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString getLV(Number method)</p>
<h3>Description</h3>Prefix the ByteString with a length field as specified by method.<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>method</td><td>Must be either TLV.EMV or TLV.DGI</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>Length field concatenated with content</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_LENGTH</td><td>Length must not exceed 65535 for DGI encoding</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_MECH</td><td>The encoding method is invalid</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("", ASCII);
y = x.getLV(TLV.EMV);
assert(y.toString(HEX) == "00");

y = x.getLV(TLV.DGI);
assert(y.toString(HEX) == "00");


x = new ByteString("123ABC", ASCII);
y = x.getLV(TLV.EMV);
assert(y.toString(HEX) == "06313233414243");

y = x.getLV(TLV.DGI);
assert(y.toString(HEX) == "06313233414243");


x = new ByteString("01234567890123456789012345678901234567890123456789012345" +
                   "67890123456789012345678901234567890123456789012345678901" +
                   "2345678901234567", ASCII);
y = x.getLV(TLV.EMV);
assert(y.equals(x.getL(TLV.EMV).concat(x)));

y = x.getLV(TLV.DGI);
assert(y.equals(x.getL(TLV.DGI).concat(x)));


x = new ByteString("01234567890123456789012345678901234567890123456789012345" +
                   "67890123456789012345678901234567890123456789012345678901" +
                   "23456789012345678901234567890123456789012345678901234567" +
                   "89012345678901234567890123456789012345678901234567890123" +
                   "45678901234567890123456789012345", ASCII);
y = x.getLV(TLV.EMV);
assert(y.equals(x.getL(TLV.EMV).concat(x)));

y = x.getLV(TLV.DGI);
assert(y.equals(x.getL(TLV.DGI).concat(x)));

</pre>
<h2 id="left">left()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString left(Number value)</p>
<h3>Description</h3>Extract the leftmost number of bytes as specified in the argument.<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>value</td><td>Number of leftmost bytes</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>New ByteString object with leftmost bytes</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_LENGTH</td><td>The length specified exceeds the length of the ByteString</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("123ABC", ASCII);
y = x.left(3);
assert(y.toString(ASCII) == "123");

y = x.left(9);
assert(y.toString(ASCII) == "123ABC");

</pre>
<h2 id="neg">neg()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString neg()</p>
<p class="signature">ByteString neg(Number size)</p>
<h3>Description</h3>
<p>Return a ByteString object with the negative binary value of the ByteString object the method is applied to.</p>
             
<p>The method calculates the ones-complement by inverting all bits and adding 1.</p>
             
<p>The method can be applied to ByteString objects of arbitrary length.</p>
             
<p>If no size argument is given, then the resulting ByteString has the same length as the ByteString object the method
                is called for</p>
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>size</td><td>The number of bytes in the resulting ByteString</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>New ByteString object with negative value</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_LENGTH</td><td>The size argument must be equals or larger than the length of the ByteString</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("0101", HEX);
y = x.neg();
assert(y.toString(HEX) == "FEFF");

x = new ByteString("0101", HEX);
y = x.neg(3);
assert(y.toString(HEX) == "FFFEFF");

x = new ByteString("0000", HEX);
y = x.neg(3);
assert(y.toString(HEX) == "000000");

x = new ByteString("FFFF", HEX);
y = x.neg();
assert(y.toString(HEX) == "0001");

x = new ByteString("", HEX);
y = x.neg();
assert(y.toString(HEX) == "");

x = new ByteString("", HEX);
y = x.neg(2);
assert(y.toString(HEX) == "0000");

</pre>
<h2 id="not">not()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString not()</p>
<h3>Description</h3>Return an new ByteString object with all bits inverted.<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>New ByteString object of same size with all bits inverted.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("0101", HEX);

y = x.not();
assert(y.toString(HEX) == "FEFE");

y = y.not();
assert(y.toString(HEX) == "0101");

x = new ByteString("", HEX);

y = x.not();
assert(y.toString(HEX) == "");

</pre>
<h2 id="or">or()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString or(ByteString value)</p>
<h3>Description</h3>Return a new ByteString object containing the bitwise OR of the ByteString object for which the method is called
                     and the argument. Both ByteString objects must have the same length.<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code><a href="bytestring.html">ByteString</a></code></td><td>value</td><td>ByteString argument.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>New ByteString object containing the result of the OR operation.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_LENGTH</td><td>The length of the ByteString argument must be equal to the length of the ByteString object.</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("AA A5 55", HEX);
y = new ByteString("55 A5 AA", HEX);
z = x.or(y);
assert(z.toString(HEX) == "FFA5FF", HEX);

</pre>
<h2 id="pad">pad()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString pad(Number method)</p>
<p class="signature">ByteString pad(Number method, Boolean optional)</p>
<h3>Description</h3>Return ByteString padded to the right according to the method
                     specified.<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>method</td><td>The padding method to use. Must be either 
                     Crypto.ISO9797_METHOD_1 or Crypto.ISO9797_METHOD_2. Method 1 will append the
                     appropriate number of '00' bytes to complete the block, whereas method 2 will
                     append an '80' followed by the appropriate number of '00' bytes.</td>
</tr>
<tr>
<td><code>Boolean</code></td><td>optional</td><td>If optional is true, then padding will only occur
                     if the length is not a multiple of the block size. Default is false.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>New ByteString object containing the extracted bytes.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_MECH</td><td>Invalid padding method</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("123ABC", HEX);

y = x.pad(Crypto.ISO9797_METHOD_1);
assert(y.toString(HEX) == "123ABC0000000000");

y = x.pad(Crypto.ISO9797_METHOD_2);
assert(y.toString(HEX) == "123ABC8000000000");

x = new ByteString("123ABC11223333", HEX);

y = x.pad(Crypto.ISO9797_METHOD_1);
assert(y.toString(HEX) == "123ABC1122333300");

y = x.pad(Crypto.ISO9797_METHOD_2);
assert(y.toString(HEX) == "123ABC1122333380");

x = new ByteString("123ABC1122333399", HEX);

y = x.pad(Crypto.ISO9797_METHOD_1, true);
assert(y.toString(HEX) == "123ABC1122333399");

y = x.pad(Crypto.ISO9797_METHOD_2, true);
assert(y.toString(HEX) == "123ABC1122333399");

</pre>
<h2 id="right">right()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString right(Number count)</p>
<h3>Description</h3>Return the rightmost bytes of the ByteString as specified by the argument.<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>count</td><td>The number of bytes to extract.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>New ByteString object containing the extracted bytes.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_LENGTH</td><td>The count argument must not exceed the length of the ByteString.</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("123ABC", ASCII);
y = x.right(3);
assert(y.toString(ASCII) == "ABC");

y = x.right(9);
assert(y.toString(ASCII) == "123ABC");

</pre>
<h2 id="startsWith">startsWith()</h2>
<h3>Prototype</h3>
<p class="signature">Number startsWith(ByteString value)</p>
<h3>Description</h3>Return the number of bytes by which the ByteString and the argument start with the same bytes.<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code><a href="bytestring.html">ByteString</a></code></td><td>value</td><td>ByteString to test against.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>Number</code></td><td>Number of equal bytes in object and argument.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("123ABC", ASCII);
y = new ByteString("123", ASCII);

assert(typeof(x.startsWith(y)) == "number");
assert(x.startsWith(y) == 3);
assert(y.startsWith(x) == 3);

y = new ByteString("1234", ASCII);
assert(x.startsWith(y) == 3);

y = new ByteString("01234", ASCII);
assert(x.startsWith(y) == 0);

</pre>
<h2 id="toBase64">toBase64()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString toBase64()</p>
<p class="signature">ByteString toBase64(Boolean linebreak)</p>
<h3>Description</h3>
<p>Return a new ByteString object containing the BASE64 encoding of the ByteString object for which the
                     method is called.</p>
                     
<p>The resulting ByteString will only contain ASCII characters.</p>
                     
<p>If the linebreak argument is true, then a newline is inserted after each 62. character (48 Bytes).</p>
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Boolean</code></td><td>linebreak</td><td>If true, a newline is inserted after each 62. character. Default is false.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>New ByteString object containing BASE64 encoded ASCII string.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("Hello World", ASCII);
y = x.toBase64();
assert(y.toString(ASCII) == "SGVsbG8gV29ybGQ=");

x = new ByteString("The quick brown fox jumped over the lazy dog12345", ASCII);
y = x.toBase64(false);
assert(y.toString(ASCII) ==
  "VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2cxMjM0NQ==");

x = new ByteString("The quick brown fox jumped over the lazy dog12345", ASCII);
y = x.toBase64(true);
assert(y.toString(ASCII) == 
  "VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2cxMjM0\nNQ==");

x = new ByteString("", ASCII);
y = x.toBase64(true);
assert(y.length == 0);

</pre>
<h2 id="toBcd">toBcd()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString toBcd()</p>
<p class="signature">ByteString toBcd(Number countBytes)</p>
<h3>Description</h3>
<p>Return a new ByteString object containing the BCD encoded binary value of the ByteString for which the method is called.</p>
                     
<p>The ByteString can be up to 63 bits long.</p>
                     
<p>If the optional countBytes argument is given, then the resulting ByteString has countBytes length. If the resulting
                        ByteString is longer than the BCD encoded value, then zeros are padded to the left. If the resulting ByteString
                        is smaller than the BCD encoded value, then only the rightmost digits are preserved.</p>
          
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>countBytes</td><td>Length of resulting ByteString.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code></code></td><td>New ByteString object containing BCD encoded value.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_LENGTH</td><td>The countBytes argument is invalid.</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("0101", HEX);
y = x.toBcd();
assert(y.toString(HEX) == "0257");

y = x.toBcd(3);
assert(y.toString(HEX) == "000257");

y = x.toBcd(1);
assert(y.toString(HEX) == "57");

x = new ByteString("7FFFFFFFFFFFFFFF", HEX);

y = x.toBcd();
assert(y.toString(HEX) == "09223372036854775807");

y = x.toBcd(0);
assert(y.toString(HEX) == "");

</pre>
<h2 id="toHex">toHex()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString toHex()</p>
<p class="signature">ByteString toHex(Number countBytes)</p>
<h3>Description</h3>
<p>Return a new ByteString object containing in ASCII the HEX encoded binary value of the ByteString for which the method is called.</p>
                     
<p>The ByteString can be of arbitrary length.</p>
                     
<p>If the optional countBytes argument is given, then the resulting ByteString has countBytes length. If the resulting
                        ByteString is longer than the HEX encoded value, then ASCII zeros ('0') are padded to the left. If the resulting ByteString
                        is smaller than the HEX encoded value, then only the rightmost digits are preserved.</p>
          
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>countBytes</td><td>Optional argument specifying the bytes the length of the resulting ByteString.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>New ByteString object containing ASCII encoded HEX string.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_LENGTH</td><td>Type countBytes argument is negativ.</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("65666768", HEX);
y = x.toHex();
assert(y.toString(ASCII) == "65666768");

x = new ByteString("65666768", HEX);
y = x.toHex(10);
assert(y.toString(ASCII) == "0065666768");

x = new ByteString("65666768", HEX);
y = x.toHex(4);
assert(y.toString(ASCII) == "6768");

x = new ByteString("", HEX);
y = x.toHex();
assert(y.toString(ASCII) == "");

</pre>
<h2 id="toSigned">toSigned()</h2>
<h3>Prototype</h3>
<p class="signature">Number toSigned()</p>
<p class="signature">Number toSigned(Boolean littleEndian)</p>
<h3>Description</h3>
<p>Return the signed binary value of the ByteString.</p>
                     
<p>The ByteString can be of arbitrary length, however the number of significant bits must not exceed 32.
                        Leading zeros for positive values or ones for negative values are skipped. The first bit in the
                        ByteString is used as sign bit.</p>
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Boolean</code></td><td>littleEndian</td><td>Assume little endian encoding format. Optional argument, default is false.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>Number</code></td><td>ByteString as 32 bit signed integer value.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.DATA_TOO_LARGE</td><td>The number of significant bits exceeds 32.</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("", HEX);
assert(typeof(x.toSigned()) == "number");
assert(x.toSigned() == 0);

x = new ByteString("0123", HEX);
assert(x.toSigned() == 0x0123);

x = new ByteString("FF", HEX);
assert(x.toSigned() == -1);

x = new ByteString("7FFFFFFF", HEX);
assert(x.toSigned() == 0x7FFFFFFF);

x = new ByteString("007FFFFFFF", HEX);
assert(x.toSigned() == 0x7FFFFFFF);

x = new ByteString("007FEDCBA0", HEX);
assert(x.toSigned() == 0x7FEDCBA0);

x = new ByteString("FFFFFFFF", HEX);
assert(x.toSigned() == -1);

x = new ByteString("FFFFFFFFFF", HEX);
assert(x.toSigned() == -1);

x = new ByteString("FF80000000", HEX);
assert(x.toSigned() == -0x80000000);

x = new ByteString("", HEX);
assert(x.toSigned(true) == 0);

x = new ByteString("0123", HEX);
assert(x.toSigned(true) == 0x2301);

x = new ByteString("FF", HEX);
assert(x.toSigned(true) == -1);

x = new ByteString("FFFFFF7F", HEX);
assert(x.toSigned(true) == 0x7FFFFFFF);

x = new ByteString("FFFFFF7F00", HEX);
assert(x.toSigned(true) == 0x7FFFFFFF);

x = new ByteString("A0CBED7F00", HEX);
assert(x.toSigned(true) == 0x7FEDCBA0);

x = new ByteString("FFFFFFFF", HEX);
assert(x.toSigned(true) == -1);

x = new ByteString("FFFFFFFFFF", HEX);
assert(x.toSigned(true) == -1);

x = new ByteString("00000080FF", HEX);
assert(x.toSigned(true) == -0x80000000);

</pre>
<h2 id="toString">toString()</h2>
<h3>Prototype</h3>
<p class="signature">String toString()</p>
<p class="signature">String toString(Number encoding)</p>
<h3>Description</h3>Return a String containing the ByteString value in the encoding specified by the argument or as hexadecimal string.<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>encoding</td><td>Encoding format, one of ASCII, UTF8, BASE64 or CN.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>String</code></td><td>String containing ByteString value in specified encoding format.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_DATA</td><td>ByteString can not be expressed in specified encoding.</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ENCODING</td><td>Unknown encoding format specified.</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("41 42 43", HEX);
assert(x.toString(HEX) == "414243");

x = new ByteString("41 42 43 C4 D6 DC DF", HEX);
assert(x.toString(ASCII) == "ABC&Auml;&Ouml;&Uuml;&szlig;");

x = new ByteString("C3 84 C3 96 C3 9C C3 9F", HEX);
assert(x.toString(UTF8) == "&Auml;&Ouml;&Uuml;&szlig;");

x = new ByteString("Hello World", ASCII);
assert(x.toString(BASE64) == "SGVsbG8gV29ybGQ=");

</pre>
<h2 id="toUnsigned">toUnsigned()</h2>
<h3>Prototype</h3>
<p class="signature">Number toUnsigned()</p>
<p class="signature">Number toUnsigned(Boolean littleEndian)</p>
<h3>Description</h3>
<p>Return the unsigned binary value of the ByteString.</p>
                     
<p>The ByteString can be of arbitrary length, however the number of significant bits must not exceed 32.
                        Leading zeros are skipped.</p>
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Boolean</code></td><td>littleEndian</td><td>Assume little endian encoding format. Optional argument, default is false.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>Number</code></td><td>ByteString as 32 bit unsigned integer value.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.DATA_TOO_LARGE</td><td>The number of significant bits exceeds 32.</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("", HEX);
assert(typeof(x.toUnsigned()) == "number");
assert(x.toUnsigned() == 0);

x = new ByteString("0123", HEX);
assert(x.toUnsigned() == 0x0123);

x = new ByteString("FF", HEX);
assert(x.toUnsigned() == 255);

x = new ByteString("FFFFFFFF", HEX);
assert(x.toUnsigned() == 0xFFFFFFFF);

x = new ByteString("00FFFFFFFF", HEX);
assert(x.toUnsigned() == 0xFFFFFFFF);

x = new ByteString("00DFEDCBA0", HEX);
assert(x.toUnsigned() == 0xDFEDCBA0);


x = new ByteString("", HEX);
assert(x.toUnsigned(true) == 0);

x = new ByteString("0123", HEX);
assert(x.toUnsigned(true) == 0x2301);

x = new ByteString("FF", HEX);
assert(x.toUnsigned(true) == 0xFF);

x = new ByteString("FFFFFF8F", HEX);
assert(x.toUnsigned(true) == 0x8FFFFFFF);

x = new ByteString("FFFFFF8F00", HEX);
assert(x.toUnsigned(true) == 0x8FFFFFFF);

x = new ByteString("A0CBED7F00", HEX);
assert(x.toUnsigned(true) == 0x7FEDCBA0);

</pre>
<h2 id="xor">xor()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString xor(ByteString value)</p>
<h3>Description</h3>Return a new ByteString object containing the bitwise exclusive or of the ByteString object for which the method is called
                     and the argument. Both ByteString objects must have the same length.<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code><a href="bytestring.html">ByteString</a></code></td><td>value</td><td>ByteString argument.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>New ByteString object containing the result of the XOR operation.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_LENGTH</td><td>The length of the ByteString argument must be equal to the length of the ByteString object.</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
</table>
<h3>Example</h3>
<pre>

x = new ByteString("AA A5 55", HEX);
y = new ByteString("55 A5 AA", HEX);
z = x.xor(y);

assert(z.toString(HEX) == "FF00FF", HEX);

</pre>
<h2 id="add">add()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString add(Number value)</p>
<h3>Description</h3>
            
<p>Returns a ByteString with the same length, which is the total of the objects value, interpreted
               as big unsigned integer value, plus the signed value.</p>
            
<p>This method is suitable for implementing sequence counters, in particular for secure messaging.</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>value</td><td>The signed value to add.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>New ByteString object that is the total of base plus value.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
</table>
<h3>Example</h3>
<pre>

var base = new ByteString("00", HEX);
var r = base.add(1)
assert(r.toString(HEX) == "01", HEX);

var r = r.add(-1)
assert(r.toString(HEX) == "00", HEX);

var r = r.add(-1)
assert(r.toString(HEX) == "FF", HEX);

var base = new ByteString("FFFFFFFFFFFFFFFF", HEX);
var r = base.add(2)
assert(r.toString(HEX) == "0000000000000001", HEX);
var r = r.add(-1)
assert(r.toString(HEX) == "0000000000000000", HEX);
var r = r.add(-1)
var base = new ByteString("FFFFFFFFFFFFFFFF", HEX);

</pre>
<h2 id="valueOf">valueOf()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString ByteString.valueOf(Number value)</p>
<p class="signature">ByteString ByteString.valueOf(Number value, Number octets)</p>
<h3>Description</h3>
            
<p>Returns a ByteString encoding the value in big endian format.</p>
            
<p>If the argument octets is not provided, the value is encoded on the minimum
               number of bytes.</p>
            
<p>If the argument octets is provided, the value is encoded on the given number of bytes,
               possibly truncating the value.</p>
            
<p>The number range is -(2^63) to 2^63 - 1.</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>value</td><td>The value to convert.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>New ByteString object encoding the integer value.</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Type of argument is invalid for call</td>
</tr>
</table>
<h3>Example</h3>
<pre>

var r = ByteString.valueOf(0);
assert(r.toString(HEX) == "00");

var r = ByteString.valueOf(0, 2);
assert(r.toString(HEX) == "0000");

var r = ByteString.valueOf(1);
assert(r.toString(HEX) == "01");

var r = ByteString.valueOf(1, 2);
assert(r.toString(HEX) == "0001");

var r = ByteString.valueOf(256);
assert(r.toString(HEX) == "0100");

var r = ByteString.valueOf(256, 1);
assert(r.toString(HEX) == "00");

var r = ByteString.valueOf(0x80000000);
assert(r.toString(HEX) == "80000000");

var r = ByteString.valueOf(-1);
assert(r.toString(HEX) == "FFFFFFFFFFFFFFFF");

var r = ByteString.valueOf(-1, 2);
assert(r.toString(HEX) == "FFFF");

</pre>
                    <!-- #EndEditable -->
<br>
<p class="copyright">&copy; Copyright 2003 - 2010 <a href="http://www.cardcontact.de">CardContact</a>
Software & System Consulting, Minden, Germany</p>
</div>

</body>
</html><!-- #EndTemplate -->
        
