<!-- #BeginTemplate "template.dwt" -->
        <!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- #BeginEditable "TITLE" -->
                <title>IsoSecureChannel - Reference Documentation</title>
                    <!-- #EndEditable -->
<link rel=stylesheet type="text/css" href="style.css">
<meta name="author" content="Andreas Schwier">
</head>
<body>
<div align="left"><a href="http://www.cardcontact.de"><img src="banner.jpg" width="750" height="80" border="0"></a></div>
<div id="navigator">
    <p><b>Smart Card<br>Shell 3</b></p>
    <a href="index.html">Home</a><br><br>
    <a href="gperror.html">GPError</a><br>
    <a href="gpsystem.html">GPSystem</a><br>
    <a href="bytestring.html">ByteString</a><br>
    <a href="bytebuffer.html">ByteBuffer</a><br>
    <a href="tlv.html">TLV</a><br>
    <a href="tlvlist.html">TLVList</a><br>
    <a href="card.html">Card</a><br>
    <a href="atr.html">Atr</a><br>
    <a href="key.html">Key</a><br>
    <a href="crypto.html">Crypto</a><br>
    <a href="application.html">Application</a><br>
    <a href="gpapplication.html">GPApplication</a><br>
    <a href="gpsecuritydomain.html">GPSecDomain</a><br>
    <br>
    <a href="asn1.html">ASN1</a><br>
    <a href="cardfile.html">CardFile</a><br>
    <a href="isosecurechannel.html">IsoSecureChannel</a><br>
    <a href="applicationfactory.html">ApplFactory</a><br>
    <a href="gpxml.html">GPXML</a><br>
    <a href="jsscript.html">JsScript</a><br>
    <a href="cardsimulationadapter.html">CardSim</a><br>
    <br>
    <a href="x509.html">X509</a><br>
    <a href="crl.html">CRL</a><br>
    <a href="keystore.html">KeyStore</a><br>
    <a href="cmssigneddata.html">CMSSignedData</a><br>
    <a href="cmsgenerator.html">CMSGenerator</a><br>
    <a href="xmlsignature.html">XMLSignature</a><br>
    <a href="ocspquery.html">OCSPQuery</a><br>
    <a href="ldap.html">LDAP</a><br>
    <a href="soapconnection.html">SOAP</a><br>
    <a href="urlconnection.html">URLConnection</a><br>
    <br>
    <a href="pkcs11provider.html">PKCS11Provider</a><br>
    <a href="pkcs11session.html">PKCS11Session</a><br>
    <a href="pkcs11object.html">PKCS11Object</a><br>
    <br>
    <a href="outlinenode.html">OutlineNode</a><br>
    <a href="dialog.html">Dialog</a><br>
    <br>
    <a href="jsdoc/index.html">Tools</a><br>
    <br>
    <a href="http://www.openscdp.org">OpenSCDP</a><br>
</div>

<div id="main">
<!-- #BeginEditable "BODY" -->
                <h1>IsoSecureChannel - Reference Documentation</h1>
<p>
        
<p>Class to support a secure communication channel via secure messaging according to ISO 7816-4
           and CWA 14890 (eSign-K).</p>
        
<p>This implementation supports 3-TDES and AES keys for MAC and encryption.</p>
        
<p>For 3-TDES keys the MAC algorithm is ISO 9797 Algorithm 3 (Retail-MAC or EMV-MAC),
           the encryption algorithm is DES-CBC.</p>
        
<p>For AES keys the MAC algorithm is AES-CMAC and the encryption algorithm is AES-CBC.</p>
        
<p>Three policies for handling send sequence counters are available:</p>
        
<p>SSC_DEFAULT_POLICY</p>
        
<p>If a send sequence counter for MAC is defined, then it
           is incremented for each new MAC and prepended to the protected message.</p>
        
<p>If a send sequence counter for encryption is defined, then it is incremented
           for each new cryptogram and used as initialisation vector.</p>
        
<p>SSC_SYNC_POLICY</p>
        
<p>If a send sequence counter for MAC is defined, then it is
           incremented for each new MAC and prepended to the protected message.</p>
        
<p>The same send sequence counter is used as initialisation vector for
           encrypted data (EAC 2.0 with 3-TDES).</p>
        
<p>SSC_SYNC_ENC_POLICY</p>
        
<p>If a send sequence counter for MAC is defined, then it is
           incremented for each new MAC and prepended to the protected message.</p>
        
<p>The same send sequence counter is encrypted and the result is used as 
           initialisation vector for encrypted data.&acute;This has the same effect as
           prepending the message to be encrypted with the SSC (EAC 2.0 with AES).</p>
    
</p>
<h2>Index of Methods</h2>
<ul>
<li>
<a href="#Constructor">IsoSecureChannel() constructor</a>
</li>
<li>
<a href="#setEncKey">setEncKey()</a>
</li>
<li>
<a href="#setMacKey">setMacKey()</a>
</li>
<li>
<a href="#setMACSendSequenceCounter">setMACSendSequenceCounter()</a>
</li>
<li>
<a href="#setEncryptionSendSequenceCounter">setEncryptionSendSequenceCounter()</a>
</li>
<li>
<a href="#setIV">setIV()</a>
</li>
<li>
<a href="#setMacLength">setMacLength()</a>
</li>
<li>
<a href="#wrap">wrap()</a>
</li>
<li>
<a href="#unwrap">unwrap()</a>
</li>
<li>
<a href="#setCRT">setCRT()</a>
</li>
</ul>
<h2>Constants</h2>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td>Number</td><td>SSC_DEFAULT_POLICY</td><td>Default SSC policy</td>
</tr>
<tr>
<td>Number</td><td>SSC_SYNC_POLICY</td><td>Same send sequence counter for MAC and encryption</td>
</tr>
<tr>
<td>Number</td><td>SSC_SYNC_ENC_POLICY</td><td>Same send sequence counter for MAC and encrypted SSC for encryption</td>
</tr>
</table>
<h2>Properties</h2>
<table class="content">
<colgroup>
<col width="100">
<col width="120">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td>ByteString</td><td>encryptionSendSequenceCounter</td><td>Current value of send sequence counter for encryption</td>
</tr>
<tr>
<td>ByteString</td><td>MACSendSequenceCounter</td><td>Current value of send sequence counter for MAC calculation</td>
</tr>
</table>
<h2 id="Constructor">Constructor</h2>
<h3>Prototype</h3>
<p class="signature">IsoSecureChannel(Crypto crypto)</p>
<p class="signature">IsoSecureChannel(Crypto crypto, Number policy)</p>
<h3>Description</h3>
            
<p>Instantiate an IsoSecureChannel object that allows to wrap command-APDUs and unwrap
               response-APDUs using secure messaging as defined in ISO 7816-4 and CWA 14890 (eSign-K).</p>
            
<p>The object instantiated with this constructor must be further initialized using
               the setEncKey(), setMacKey() and setMACSendSequenceCounter() methods.</p>
            
<p>The class only supports 3DES/CBC and RetailMAC as cryptographic algorithms using a double or triple length DES key.</p>
            
<p>Objects of this class can be used in Card.setCredential() and CardFile.setCredential() as
               credential object.</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Crypto</code></td><td>crypto</td><td>Crypto object to use for cryptographic operations</td>
</tr>
<tr>
<td><code>Number</code></td><td>policy</td><td>One of SSC_DEFAULT_POLICY, SSC_SYNC_POLICY or SSC_SYNC_ENC_POLICY</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
</table>
<h3>Example</h3>
<pre>

var crypto = new Crypto();
var isc = new IsoSecureChannel(crypto);

</pre>
<h2 id="setEncKey">setEncKey()</h2>
<h3>Prototype</h3>
<p class="signature">void setEncKey(Key kenc)</p>
<h3>Description</h3>
            
<p>Set the key to be used for encryption of command-APDUs and decryption of
               response-APDUs.</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Key</code></td><td>kenc</td><td>The encryption key</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>void</code></td><td>The method does not return a value</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Argument must be of type Key</td>
</tr>
</table>
<h3>Example</h3>
<pre>

var kencval = new ByteString("7CA110454A1A6E570131D9619DC1376E4A1A6E570131D961", HEX);
var kenc = new Key();
kenc.setComponent(Key.DES, kencval);

isc.setEncKey(kenc);

</pre>
<h2 id="setMacKey">setMacKey()</h2>
<h3>Prototype</h3>
<p class="signature">void setMacKey(Key kmac)</p>
<h3>Description</h3>
            
<p>Set the key to be used for calculating and verifying the message authentication code (MAC).</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Key</code></td><td>kmac</td><td>The message authentication key</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>void</code></td><td>The method does not return a value</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>Argument must be of type Key</td>
</tr>
</table>
<h3>Example</h3>
<pre>

var kmacval = new ByteString("0131D9619DC1376E7CA110454A1A6E579DC1376E7CA11045", HEX);
var kmac = new Key();
kmac.setComponent(Key.DES, kmacval);

isc.setMacKey(kmac);

</pre>
<h2 id="setMACSendSequenceCounter">setMACSendSequenceCounter()</h2>
<h3>Prototype</h3>
<p class="signature">void setMACSendSequencCounter(ByteString ssc)</p>
<h3>Description</h3>
            
<p>Set the initial value for the send sequence counter using for message authentication codes.</p>
            
<p>If a send sequence counter is defined, then this counter will be incremented
               for each command or response APDU that contains a MAC.</p>
            
<p>The deprecated setSendSequenceCounter() maps to this method.</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code><a href="bytestring.html">ByteString</a></code></td><td>ssc</td><td>The initial value for the send sequence counter or null</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>void</code></td><td>The method does not return a value</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>The argument must be of type ByteString</td>
</tr>
</table>
<h3>Example</h3>
<pre>

var ssc = new ByteString("FFFFFFFFFFFFFFF6", HEX);
isc.setMACSendSequenceCounter(ssc);

</pre>
<h2 id="setEncryptionSendSequenceCounter">setEncryptionSendSequenceCounter()</h2>
<h3>Prototype</h3>
<p class="signature">void setEncryptionSendSequencCounter(ByteString ssc)</p>
<h3>Description</h3>
            
<p>Set the initial value for the send sequence counter used for encryption.</p>
            
<p>If a send sequence counter is defined, then this counter will be incremented
               for each command or response APDU that contains encrypted contents.</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code><a href="bytestring.html">ByteString</a></code></td><td>ssc</td><td>The initial value for the send sequence counter or null</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>void</code></td><td>The method does not return a value</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>The argument must be of type ByteString</td>
</tr>
</table>
<h3>Example</h3>
<pre>

// see setMACSendSequenceCounter() for an example.

</pre>
<h2 id="setIV">setIV()</h2>
<h3>Prototype</h3>
<p class="signature">void setIV(ByteString iv)</p>
<h3>Description</h3>
            
<p>Set the initial vector for DES/CBC encryption and decryption.</p>
            
<p>The default value used without using this method is '0000000000000000'.</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code><a href="bytestring.html">ByteString</a></code></td><td>iv</td><td>The initial vector or null</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>void</code></td><td>The method does not return a value</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>The argument must be of type ByteString</td>
</tr>
</table>
<h3>Example</h3>
<pre>

var iv = new ByteString("1111111111111111", HEX);
isc.setIV(iv);

</pre>
<h2 id="setMacLength">setMacLength()</h2>
<h3>Prototype</h3>
<p class="signature">void setMacLength(Number maclen)</p>
<h3>Description</h3>
            
<p>Set the length of the message authentication code as number of most significant
               bytes from the last cryptographic operation.</p>
            
<p>The default value is 8 byte.</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code>Number</code></td><td>maclen</td><td>The number of leftmost / most significant bytes to be used as MAC</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>void</code></td><td>The method does not return a value</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>The argument must be of type ByteString</td>
</tr>
</table>
<h3>Example</h3>
<pre>

isc.setMacLength(8);

</pre>
<h2 id="wrap">wrap()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString wrap(ByteString apduToWrap, Number usageQualifier)</p>
<h3>Description</h3>
            
<p>Wrap a command-APDU with a secure messaging block.</p>
            
<p>Depending on the usageQualifier, no transformation (0), an encryption (Card.CENC), a MAC
	   calculation (Card.CPRO) or both (Card.CENC|Card.CPRO) is performed.</p>
	
<p>The APDU is transformed as defined in ISO 7816-4 and CWA 14890 (eSignK).</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code><a href="bytestring.html">ByteString</a></code></td><td>apduToWrap</td><td>The command APDU to wrap</td>
</tr>
<tr>
<td><code>Number</code></td><td>usageQualifier</td><td>A bitwise combination of Card.CPRO and Card.CENC.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>Wrapped command APDU</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>The type of the argument passed to the method is invalid</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_MECH</td><td>The cryptographic operating is not supported by the selected crypto service</td>
</tr>
</table>
<h3>Example</h3>
<pre>

// #### Using 3-TDES with short APDUs ####

var ssc = new ByteString("FFFFFFFFFFFFFFF6", HEX);
isc.setMACSendSequenceCounter(ssc);

// Case 1 Command APDU CLA=00 INS=10 P1=20 P2=30
var apdu = new ByteString("00102030", HEX);

// Case 1 Plain 	-&gt; CLA'|INS|P1|P2
var r = isc.wrap(apdu, 0);

// Test result
assert(r.toString(16) == "08102030");
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFF6");



// Case 1 CENC  	-&gt; CLA'|INS|P1|P2
var r = isc.wrap(apdu, Card.CENC);

// Test result
assert(r.toString(16) == "08102030");
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFF6");



// Case 1 CPRO		-&gt; CLA'|INS|P1|P2|Lc'|TLmac
var r = isc.wrap(apdu, Card.CPRO);

// Test result
var exp = new ByteString("0C1020300A8E08", HEX);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, new ByteString(
            "FFFFFFFFFFFFFFF70C10203080000000", HEX));
exp = exp.concat(mac);
assert(r.equals(exp));



// Case 1 CENC|CPRO	-&gt; CLA'|INS|P1|P2|Lc'|TLmac
var r = isc.wrap(apdu, Card.CENC|Card.CPRO);

// Test result
var exp = new ByteString("0C1020300A8E08", HEX);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, new ByteString(
            "FFFFFFFFFFFFFFF80C10203080000000", HEX));
exp = exp.concat(mac);
assert(r.equals(exp));



// Case 2s Command APDU CLA=00 INS=10 P1=20 P2=30 Le=80
var apdu = new ByteString("0010203080", HEX);

// Case 2s Plain		-&gt; CLA'|INS|P1|P2|Lc'|TLle|00
var r = isc.wrap(apdu, 0);

// Test result
assert(r.toString(16) == "081020300396018000");
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFF8");



// Case 2s CENC		-&gt; CLA'|INS|P1|P2|Lc'|TLle|00
var r = isc.wrap(apdu, Card.CENC);

// Test result
assert(r.toString(16) == "081020300396018000");
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFF8");



// Case 2s CPRO		-&gt; CLA'|INS|P1|P2|Lc'|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CPRO);

// Test result
var exp = new ByteString("0C1020300D9701808E08", HEX);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, new ByteString(
            "FFFFFFFFFFFFFFF90C102030800000009701808000000000", HEX));
exp = exp.concat(mac).concat(new ByteString("00", HEX));
assert(r.equals(exp));



// Case 2s CENC|CPRO	-&gt; CLA'|INS|P1|P2|Lc'|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CPRO|Card.CENC);

// Test result
var exp = new ByteString("0C1020300D9701808E08", HEX);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, new ByteString(
            "FFFFFFFFFFFFFFFA0C102030800000009701808000000000", HEX));
exp = exp.concat(mac).concat(new ByteString("00", HEX));
assert(r.equals(exp));



// Case 3s Command APDU CLA=00 INS=10 P1=20 P2=30 Lc=04 Data=41424344
var apdu = new ByteString("001020300441424344", HEX);

// Case 3s Plain		-&gt; CLA'|INS|P1|P2|Lc'|TLplain
var r = isc.wrap(apdu, 0);

// Test result
assert(r.toString(16) == "0810203006800441424344");
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFFA");



// Case 3s CENC		-&gt; CLA'|INS|P1|P2|Lc'|TLenc
var r = isc.wrap(apdu, Card.CENC);

// Test result
var exp = new ByteString("081020300B860901", HEX);
var enc = crypto.encrypt(kenc, Crypto.DES_CBC, 
            new ByteString("4142434480000000", HEX), iv);
exp = exp.concat(enc);
assert(r.equals(exp));
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFFB");



// Case 3s CPRO		-&gt; CLA'|INS|P1|P2|Lc'|TLplain|TLmac
var r = isc.wrap(apdu, Card.CPRO);

// Test result
var exp = new ByteString("0C102030108104414243448E08", HEX);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, new ByteString(
            "FFFFFFFFFFFFFFFC0C102030800000008104414243448000", HEX));
exp = exp.concat(mac);
assert(r.equals(exp));


// Case 3s CENC|CPRO	-&gt; CLA'|INS|P1|P2|Lc'|TLenc|TLmac
var r = isc.wrap(apdu, Card.CENC|Card.CPRO);

// Test result
var exp = new ByteString("0C10203015870901", HEX);
var enc = crypto.encrypt(kenc, Crypto.DES_CBC, 
            new ByteString("4142434480000000", HEX), iv);
exp = exp.concat(enc);
exp = exp.concat(new ByteString("8E08", HEX));
var macinp = new ByteString("FFFFFFFFFFFFFFFD0C10203080000000870901", HEX);
macinp = macinp.concat(enc);
macinp = macinp.concat(new ByteString("8000000000", HEX));
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, macinp);
exp = exp.concat(mac);
assert(r.equals(exp));



// Case 4s Command APDU CLA=00 INS=10 P1=20 P2=30 Lc=04 Data=41424344 Le=80
var apdu = new ByteString("00102030044142434480", HEX);

// Case 4s Plain		-&gt; CLA'|INS|P1|P2|Lc'|TLplain|TLle|00
var r = isc.wrap(apdu, 0);

// Test result
assert(r.toString(16) == "081020300980044142434496018000");
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFFD");



// Case 4s CENC		-&gt; CLA'|INS|P1|P2|Lc'|TLenc|TLle|00
var r = isc.wrap(apdu, Card.CENC);

// Test result
var exp = new ByteString("081020300E860901", HEX);
var enc = crypto.encrypt(kenc, Crypto.DES_CBC, 
            new ByteString("4142434480000000", HEX), iv);
exp = exp.concat(enc);
exp = exp.concat(new ByteString("96018000", HEX));
assert(r.equals(exp));
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFFE");



// Case 4s CPRO		-&gt; CLA'|INS|P1|P2|Lc'|TLplain|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CPRO);

// Test result
var exp = new ByteString("0C102030138104414243449701808E08", HEX);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, new ByteString(
            "FFFFFFFFFFFFFFFF0C1020308000000081044142434497018080000000000000", HEX));
exp = exp.concat(mac).concat(new ByteString("00", HEX));
assert(r.equals(exp));



// Case 4s CENC|CPRO	-&gt; CLA'|INS|P1|P2|Lc'|TLenc|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CENC|Card.CPRO);

// Test result
var exp = new ByteString("0C10203018870901", HEX);
var enc = crypto.encrypt(kenc, Crypto.DES_CBC, 
            new ByteString("4142434480000000", HEX), iv);
exp = exp.concat(enc);
exp = exp.concat(new ByteString("9701808E08", HEX));
var macinp = new ByteString("00000000000000000C10203080000000870901", HEX);
macinp = macinp.concat(enc);
macinp = macinp.concat(new ByteString("970180", HEX));
macinp = macinp.concat(new ByteString("8000", HEX));
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, macinp);
exp = exp.concat(mac).concat(new ByteString("00", HEX));
assert(r.equals(exp));


//#### Using 3-TDES with extended APDUs ####

var ssc = new ByteString("FFFFFFFFFFFFFFF8", HEX);
isc.setMACSendSequenceCounter(ssc);

//Case 2e Command APDU CLA=00 INS=10 P1=20 P2=30 Le=000180
var apdu = new ByteString("00102030000180", HEX);

// Case 2e Plain		-&gt; CLA'|INS|P1|P2|Lc'|TLle|00
var r = isc.wrap(apdu, 0);

// Test result
assert(r.toString(16) == "08102030000004960201800000");
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFF8");



// Case 2e CENC		-&gt; CLA'|INS|P1|P2|Lc'|TLle|00
var r = isc.wrap(apdu, Card.CENC);

// Test result
assert(r.toString(16) == "08102030000004960201800000");
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFF8");



// Case 2e CPRO		-&gt; CLA'|INS|P1|P2|Lc'|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CPRO);

// Test result
var exp = new ByteString("0C10203000000E970201808E08", HEX);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, new ByteString(
            "FFFFFFFFFFFFFFF90C102030800000009702018080000000", HEX));
exp = exp.concat(mac).concat(new ByteString("0000", HEX));
// print("Expected " + exp);
// print("Received " + r);
assert(r.equals(exp));



// Case 2e CENC|CPRO	-&gt; CLA'|INS|P1|P2|Lc'|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CPRO|Card.CENC);

// Test result
var exp = new ByteString("0C10203000000E970201808E08", HEX);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, new ByteString(
            "FFFFFFFFFFFFFFFA0C102030800000009702018080000000", HEX));
exp = exp.concat(mac).concat(new ByteString("0000", HEX));
assert(r.equals(exp));



//Case 3e Command APDU CLA=00 INS=10 P1=20 P2=30 Lc=04 Data=41424344
var apdu = new ByteString("0010203000000441424344", HEX);

// Case 3e Plain		-&gt; CLA'|INS|P1|P2|Lc'|TLplain
var r = isc.wrap(apdu, 0);

// Test result
assert(r.toString(16) == "08102030000006800441424344");
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFFA");



// Case 3e CENC		-&gt; CLA'|INS|P1|P2|Lc'|TLenc
var r = isc.wrap(apdu, Card.CENC);

// Test result
var exp = new ByteString("0810203000000B860901", HEX);
var enc = crypto.encrypt(kenc, Crypto.DES_CBC, 
            new ByteString("4142434480000000", HEX), iv);
exp = exp.concat(enc);
assert(r.equals(exp));
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFFB");



// Case 3e CPRO		-&gt; CLA'|INS|P1|P2|Lc'|TLplain|TLmac
var r = isc.wrap(apdu, Card.CPRO);

// Test result
var exp = new ByteString("0C1020300000108104414243448E08", HEX);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, new ByteString(
            "FFFFFFFFFFFFFFFC0C102030800000008104414243448000", HEX));
exp = exp.concat(mac);
assert(r.equals(exp));


// Case 3e CENC|CPRO	-&gt; CLA'|INS|P1|P2|Lc'|TLenc|TLmac
var r = isc.wrap(apdu, Card.CENC|Card.CPRO);

// Test result
var exp = new ByteString("0C102030000015870901", HEX);
var enc = crypto.encrypt(kenc, Crypto.DES_CBC, 
            new ByteString("4142434480000000", HEX), iv);
exp = exp.concat(enc);
exp = exp.concat(new ByteString("8E08", HEX));
var macinp = new ByteString("FFFFFFFFFFFFFFFD0C10203080000000870901", HEX);
macinp = macinp.concat(enc);
macinp = macinp.concat(new ByteString("8000000000", HEX));
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, macinp);
exp = exp.concat(mac);
assert(r.equals(exp));



//Case 4e Command APDU CLA=00 INS=10 P1=20 P2=30 Lc=000004 Data=41424344 Le=000180
var apdu = new ByteString("00102030000004414243440180", HEX);

// Case 4e Plain		-&gt; CLA'|INS|P1|P2|Lc'|TLplain|TLle|00
var r = isc.wrap(apdu, 0);

// Test result
assert(r.toString(16) == "0810203000000A800441424344960201800000");
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFFD");



// Case 4e CENC		-&gt; CLA'|INS|P1|P2|Lc'|TLenc|TLle|00
var r = isc.wrap(apdu, Card.CENC);

// Test result
var exp = new ByteString("0810203000000F860901", HEX);
var enc = crypto.encrypt(kenc, Crypto.DES_CBC, 
            new ByteString("4142434480000000", HEX), iv);
exp = exp.concat(enc);
exp = exp.concat(new ByteString("960201800000", HEX));
assert(r.equals(exp));
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFFE");



// Case 4e CPRO		-&gt; CLA'|INS|P1|P2|Lc'|TLplain|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CPRO);

// Test result
var exp = new ByteString("0C102030000014810441424344970201808E08", HEX);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, new ByteString(
            "FFFFFFFFFFFFFFFF0C1020308000000081044142434497020180800000000000", HEX));
exp = exp.concat(mac).concat(new ByteString("0000", HEX));
assert(r.equals(exp));



// Case 4e CENC|CPRO	-&gt; CLA'|INS|P1|P2|Lc'|TLenc|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CENC|Card.CPRO);

// Test result
var exp = new ByteString("0C102030000019870901", HEX);
var enc = crypto.encrypt(kenc, Crypto.DES_CBC, 
            new ByteString("4142434480000000", HEX), iv);
exp = exp.concat(enc);
exp = exp.concat(new ByteString("970201808E08", HEX));
var macinp = new ByteString("00000000000000000C10203080000000870901", HEX);
macinp = macinp.concat(enc);
macinp = macinp.concat(new ByteString("97020180", HEX));
macinp = macinp.concat(new ByteString("80", HEX));
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, macinp);
exp = exp.concat(mac).concat(new ByteString("0000", HEX));
assert(r.equals(exp));



// Special case: No MAC and no ENC
var ssc = new ByteString("FFFFFFFFFFFFFFF8", HEX);
isc.setMACSendSequenceCounter(ssc);

//Case 2e Command APDU CLA=00 INS=10 P1=20 P2=30 Le=000180
var apdu = new ByteString("00102030000000", HEX);

// Case 2e Plain		-&gt; CLA'|INS|P1|P2|Lc'|TLle|00
var r = isc.wrap(apdu, 0);

// Test result
assert(r.toString(16) == "08102030000004960200000000");
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFF8");




// Using AES with SSC default policy

var isc = new IsoSecureChannel(crypto);

var kencval = new ByteString("7CA110454A1A6E570131D9619DC1376E", HEX);
var kenc = new Key();
kenc.setComponent(Key.AES, kencval);

isc.setEncKey(kenc);


var kmacval = new ByteString("0131D9619DC1376E7CA110454A1A6E57", HEX);
var kmac = new Key();
kmac.setComponent(Key.AES, kmacval);

isc.setMacKey(kmac);

var ssc = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6", HEX);
isc.setMACSendSequenceCounter(ssc);

var iv = new ByteString("11111111111111111111111111111111", HEX);
isc.setIV(iv);

//Case 4s Command APDU CLA=00 INS=10 P1=20 P2=30 Lc=04 Data=41424344 Le=80
var apdu = new ByteString("00102030044142434480", HEX);

//Case 4s CENC|CPRO	-&gt; CLA'|INS|P1|P2|Lc'|TLenc|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CENC|Card.CPRO);

//Test result
var exp = new ByteString("0C10203020871101", HEX);
var enc = crypto.encrypt(kenc, Crypto.AES_CBC, 
            new ByteString("41424344800000000000000000000000", HEX), iv);
exp = exp.concat(enc);
exp = exp.concat(new ByteString("9701808E08", HEX));
var macinp = new ByteString(
            "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF70C" +
			"102030800000000000000000000000871101", HEX);
macinp = macinp.concat(enc);
macinp = macinp.concat(new ByteString("970180", HEX));
macinp = macinp.concat(new ByteString("80000000000000000000", HEX));
var mac = crypto.sign(kmac, Crypto.AES_CMAC, macinp);
exp = exp.concat(mac.left(8)).concat(new ByteString("00", HEX));

// print("Expected " + exp);
// print("Received " + r);

assert(r.equals(exp));



// Using AES with SSC_SYNC_POLICY

var isc = new IsoSecureChannel(crypto, IsoSecureChannel.SSC_SYNC_POLICY);

var kencval = new ByteString("7CA110454A1A6E570131D9619DC1376E", HEX);
var kenc = new Key();
kenc.setComponent(Key.AES, kencval);

isc.setEncKey(kenc);


var kmacval = new ByteString("0131D9619DC1376E7CA110454A1A6E57", HEX);
var kmac = new Key();
kmac.setComponent(Key.AES, kmacval);

isc.setMacKey(kmac);

var ssc = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6", HEX);
isc.setMACSendSequenceCounter(ssc);
var nextssc = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7", HEX);

var iv = new ByteString("00000000000000000000000000000000", HEX);


//Case 4s Command APDU CLA=00 INS=10 P1=20 P2=30 Lc=04 Data=41424344 Le=80
var apdu = new ByteString("00102030044142434480", HEX);

//Case 4s CENC|CPRO	-&gt; CLA'|INS|P1|P2|Lc'|TLenc|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CENC|Card.CPRO);

//Test result
var exp = new ByteString("0C10203020871101", HEX);
var enc = crypto.encrypt(kenc, Crypto.AES_CBC, new ByteString(
            "41424344800000000000000000000000", HEX), nextssc);
exp = exp.concat(enc);
exp = exp.concat(new ByteString("9701808E08", HEX));

var macinp = nextssc.concat(new ByteString(
            "0C102030800000000000000000000000871101", HEX));
macinp = macinp.concat(enc);
macinp = macinp.concat(new ByteString("970180", HEX));
macinp = macinp.concat(new ByteString("80000000000000000000", HEX));
var mac = crypto.sign(kmac, Crypto.AES_CMAC, macinp);
exp = exp.concat(mac.left(8)).concat(new ByteString("00", HEX));

// print("Expected " + exp);
// print("Received " + r);

assert(r.equals(exp));


//Using AES with SSC_SYNC_POLICY

var isc = new IsoSecureChannel(crypto, IsoSecureChannel.SSC_SYNC_ENC_POLICY);

var kencval = new ByteString("7CA110454A1A6E570131D9619DC1376E", HEX);
var kenc = new Key();
kenc.setComponent(Key.AES, kencval);

isc.setEncKey(kenc);


var kmacval = new ByteString("0131D9619DC1376E7CA110454A1A6E57", HEX);
var kmac = new Key();
kmac.setComponent(Key.AES, kmacval);

isc.setMacKey(kmac);

var ssc = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6", HEX);
isc.setMACSendSequenceCounter(ssc);
var nextssc = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7", HEX);

var iv = new ByteString("00000000000000000000000000000000", HEX);


//Case 4s Command APDU CLA=00 INS=10 P1=20 P2=30 Lc=04 Data=41424344 Le=80
var apdu = new ByteString("00102030044142434480", HEX);

//Case 4s CENC|CPRO	-&gt; CLA'|INS|P1|P2|Lc'|TLenc|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CENC|Card.CPRO);

//Test result
var exp = new ByteString("0C10203020871101", HEX);
var niv = crypto.encrypt(kenc, Crypto.AES_CBC, nextssc, iv);
var enc = crypto.encrypt(kenc, Crypto.AES_CBC, new ByteString(
            "41424344800000000000000000000000", HEX), niv);
exp = exp.concat(enc);
exp = exp.concat(new ByteString("9701808E08", HEX));

var macinp = nextssc.concat(new ByteString(
            "0C102030800000000000000000000000871101", HEX));
macinp = macinp.concat(enc);
macinp = macinp.concat(new ByteString("970180", HEX));
macinp = macinp.concat(new ByteString("80000000000000000000", HEX));
var mac = crypto.sign(kmac, Crypto.AES_CMAC, macinp);
exp = exp.concat(mac.left(8)).concat(new ByteString("00", HEX));

// print("Expected " + exp);
// print("Received " + r);

assert(r.equals(exp));



//Using AES with SSC default policy and odd instruction byte

var isc = new IsoSecureChannel(crypto);

var kencval = new ByteString("7CA110454A1A6E570131D9619DC1376E", HEX);
var kenc = new Key();
kenc.setComponent(Key.AES, kencval);

isc.setEncKey(kenc);


var kmacval = new ByteString("0131D9619DC1376E7CA110454A1A6E57", HEX);
var kmac = new Key();
kmac.setComponent(Key.AES, kmacval);

isc.setMacKey(kmac);

var ssc = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6", HEX);
isc.setMACSendSequenceCounter(ssc);

var iv = new ByteString("11111111111111111111111111111111", HEX);
isc.setIV(iv);

//Case 4s Command APDU CLA=00 INS=11 P1=20 P2=30 Lc=04 Data=41424344 Le=80
var apdu = new ByteString("00112030048002123480", HEX);

//Case 4s CENC|CPRO	-&gt; CLA'|INS|P1|P2|Lc'|TLenc|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CENC|Card.CPRO);

//Test result
var exp = new ByteString("0C1120301F8510", HEX);
var enc = crypto.encrypt(kenc, Crypto.AES_CBC, new ByteString(
            "80021234800000000000000000000000", HEX), iv);
exp = exp.concat(enc);
exp = exp.concat(new ByteString("9701808E08", HEX));
var macinp = new ByteString(
            "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF70C" +
            "1120308000000000000000000000008510", HEX);
macinp = macinp.concat(enc);
macinp = macinp.concat(new ByteString("970180", HEX));
macinp = macinp.concat(new ByteString("8000000000000000000000", HEX));
var mac = crypto.sign(kmac, Crypto.AES_CMAC, macinp);
exp = exp.concat(mac.left(8)).concat(new ByteString("00", HEX));

print("Expected " + exp);
print("Received " + r);

assert(r.equals(exp));

</pre>
<h2 id="unwrap">unwrap()</h2>
<h3>Prototype</h3>
<p class="signature">ByteString unwrap(ByteString apduToUnwrap, Number usageQualifier)</p>
<h3>Description</h3>
            
<p>Unwrap a response-APDU from a secure messaging block and check the encryption and MAC.</p>
            
<p>Depending on the usageQualifier, no transformation (0), an decryption (Card.RENC), a MAC
	   verification (Card.RPRO) or both (Card.RENC|Card.RPRO) is performed.</p>
	
<p>The APDU is transformed as defined in ISO 7816-4 and CWA 14890 (eSignK).</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code><a href="bytestring.html">ByteString</a></code></td><td>apduToUnwrap</td><td>The response APDU to unwrap</td>
</tr>
<tr>
<td><code>Number</code></td><td>usageQualifier</td><td>A bitwise combination of Card.RPRO and Card.RENC.</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>ByteString</code></td><td>Unwrapped response APDU</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>The type of the argument passed to the method is invalid</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_MECH</td><td>The cryptographic operating is not supported by the selected crypto service</td>
</tr>
<tr>
<td>GPError</td><td>GPError.CRYPTO_FAILED</td><td>Either the MAC verification or data block decryption failed</td>
</tr>
</table>
<h3>Example</h3>
<pre>

var isc = new IsoSecureChannel(crypto);

var kencval = new ByteString("7CA110454A1A6E570131D961" + 
                             "9DC1376E4A1A6E570131D961", HEX);
var kenc = new Key();
kenc.setComponent(Key.DES, kencval);
isc.setEncKey(kenc);

var kmacval = new ByteString("0131D9619DC1376E7CA11045" +
                             "4A1A6E579DC1376E7CA11045", HEX);
var kmac = new Key();
kmac.setComponent(Key.DES, kmacval);
isc.setMacKey(kmac);

var iv = new ByteString("1111111111111111", HEX);
isc.setIV(iv);

var ssc = new ByteString("0000000000000000", HEX);
isc.setMACSendSequenceCounter(ssc);

// SW1/SW2 only, Plain			-&gt; SW1/SW2
// Prepare response from ICC
var apdu = new ByteString("9000", HEX);

var r = isc.unwrap(apdu, 0);

// Test result
assert(r.toString(16) == "9000");



// SW1/SW2 only, RPRO			-&gt; TLmac|SW1/SW2
// Prepare response from ICC
var apdu = new ByteString("8E08", HEX);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, new ByteString(
            "00000000000000018000000000000000", HEX));
apdu = apdu.concat(mac);
apdu = apdu.concat(new ByteString("9000", HEX));

var r = isc.unwrap(apdu, Card.RPRO);

// Test result
assert(r.toString(16) == "9000");



// SW1/SW2 only, RPRO with SW1SW2	-&gt; TLsw|TLmac|SW1/SW2
// Prepare response from ICC
var apdu = new ByteString("990212348E08", HEX);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, new ByteString(
            "00000000000000029902123480000000", HEX));
apdu = apdu.concat(mac);
apdu = apdu.concat(new ByteString("9000", HEX));

var r = isc.unwrap(apdu, Card.RPRO);

// Test result
assert(r.toString(16) == "1234");



// Data | SW1/SW2, Plain		-&gt; TLplain|SW1/SW2
// Prepare response from ICC
var apdu = new ByteString("8004414243449000", HEX);

var r = isc.unwrap(apdu, 0);

// Test result
assert(r.toString(16) == "414243449000");



// Data | SW1/SW2, RENC			-&gt; TLenc|SW1/SW2
// Prepare response from ICC
var apdu = new ByteString("860901", HEX);
var enc = crypto.encrypt(kenc, Crypto.DES_CBC, new ByteString(
            "4142434480000000", HEX), iv);
apdu = apdu.concat(enc);
apdu = apdu.concat(new ByteString("9000", HEX));

var r = isc.unwrap(apdu, Card.RENC);

// Test result
assert(r.toString(16) == "414243449000");
assert(isc.sendSequenceCounter.toString(16) == "0000000000000003");



// Data | SW1/SW2, RPRO			-&gt; TLplain|TLmac|SW1/SW2
// Prepare response from ICC
var apdu = new ByteString("810441424344", HEX);
var macinp = new ByteString("0000000000000004", HEX);
macinp = macinp.concat(apdu);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, macinp.pad(Crypto.ISO9797_METHOD_2));
apdu = apdu.concat(new ByteString("8E08", HEX));
apdu = apdu.concat(mac);
apdu = apdu.concat(new ByteString("9000", HEX));

var r = isc.unwrap(apdu, Card.RPRO);

// Test result
assert(r.toString(16) == "414243449000");



// Data | SW1/SW2, RPRO with SW1/SW2	-&gt; TLplain|TLsw|TLmac|SW1/SW2
// Prepare response from ICC
var apdu = new ByteString("81044142434499021234", HEX);
var macinp = new ByteString("0000000000000005", HEX);
macinp = macinp.concat(apdu);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, macinp.pad(Crypto.ISO9797_METHOD_2));
apdu = apdu.concat(new ByteString("8E08", HEX));
apdu = apdu.concat(mac);
apdu = apdu.concat(new ByteString("9000", HEX));

var r = isc.unwrap(apdu, Card.RPRO);

// Test result
assert(r.toString(16) == "414243441234");



// Data | SW1/SW2, RENC|RPRO		-&gt; TLenc|TLmac|SW1/SW2
// Prepare response from ICC
var apdu = new ByteString("870901", HEX);
var enc = crypto.encrypt(kenc, Crypto.DES_CBC, new ByteString(
            "4142434480000000", HEX), iv);
apdu = apdu.concat(enc);
var macinp = new ByteString("0000000000000006", HEX);
macinp = macinp.concat(apdu);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, macinp.pad(Crypto.ISO9797_METHOD_2));
apdu = apdu.concat(new ByteString("8E08", HEX));
apdu = apdu.concat(mac);
apdu = apdu.concat(new ByteString("9000", HEX));

var r = isc.unwrap(apdu, Card.RPRO|Card.RENC);

// Test result
assert(r.toString(16) == "414243449000");



// Data | SW1/SW2, RENC|RPRO with SW1/SW2	-&gt; TLenc|TLsw|TLmac|SW1/SW2
// Prepare response from ICC
var apdu = new ByteString("870901", HEX);
var enc = crypto.encrypt(kenc, Crypto.DES_CBC, new ByteString(
            "4142434480000000", HEX), iv);
apdu = apdu.concat(enc);
apdu = apdu.concat(new ByteString("99021234", HEX));
var macinp = new ByteString("0000000000000007", HEX);
macinp = macinp.concat(apdu);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, macinp.pad(Crypto.ISO9797_METHOD_2));
apdu = apdu.concat(new ByteString("8E08", HEX));
apdu = apdu.concat(mac);
apdu = apdu.concat(new ByteString("9000", HEX));

var r = isc.unwrap(apdu, Card.RPRO|Card.RENC);

// Test result
assert(r.toString(16) == "414243441234");



// Using AES with default policy

var isc = new IsoSecureChannel(crypto);

var kencval = new ByteString("7CA110454A1A6E570131D9619DC1376E", HEX);
var kenc = new Key();
kenc.setComponent(Key.AES, kencval);

isc.setEncKey(kenc);


var kmacval = new ByteString("0131D9619DC1376E7CA110454A1A6E57", HEX);
var kmac = new Key();
kmac.setComponent(Key.AES, kmacval);

isc.setMacKey(kmac);

var ssc = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6", HEX);
isc.setMACSendSequenceCounter(ssc);

var iv = new ByteString("11111111111111111111111111111111", HEX);
isc.setIV(iv);


//Data | SW1/SW2, RENC|RPRO with SW1/SW2	-&gt; TLenc|TLsw|TLmac|SW1/SW2
//Prepare response from ICC
var apdu = new ByteString("871101", HEX);
var enc = crypto.encrypt(kenc, Crypto.AES_CBC, new ByteString(
            "41424344800000000000000000000000", HEX), iv);
apdu = apdu.concat(enc);
apdu = apdu.concat(new ByteString("99021234", HEX));
var macinp = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7", HEX);
macinp = macinp.concat(apdu);
macinp = macinp.concat(new ByteString("800000000000000000", HEX));
var mac = crypto.sign(kmac, Crypto.AES_CMAC, macinp);
apdu = apdu.concat(new ByteString("8E08", HEX));
apdu = apdu.concat(mac.left(8));
apdu = apdu.concat(new ByteString("9000", HEX));

// print("APDU " + apdu);
var r = isc.unwrap(apdu, Card.RPRO|Card.RENC);

// print("Received " + r);

//Test result
assert(r.toString(16) == "414243441234");



//Using AES with SSC_SYNC_POLICY

var isc = new IsoSecureChannel(crypto, IsoSecureChannel.SSC_SYNC_POLICY);

var kencval = new ByteString("7CA110454A1A6E570131D9619DC1376E", HEX);
var kenc = new Key();
kenc.setComponent(Key.AES, kencval);

isc.setEncKey(kenc);


var kmacval = new ByteString("0131D9619DC1376E7CA110454A1A6E57", HEX);
var kmac = new Key();
kmac.setComponent(Key.AES, kmacval);

isc.setMacKey(kmac);

var ssc = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6", HEX);
isc.setMACSendSequenceCounter(ssc);
var nextssc = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7", HEX);

var iv = new ByteString("00000000000000000000000000000000", HEX);


//Data | SW1/SW2, RENC|RPRO with SW1/SW2	-&gt; TLenc|TLsw|TLmac|SW1/SW2
//Prepare response from ICC
var apdu = new ByteString("871101", HEX);
var enc = crypto.encrypt(kenc, Crypto.AES_CBC, new ByteString(
            "41424344800000000000000000000000", HEX), nextssc);
apdu = apdu.concat(enc);
apdu = apdu.concat(new ByteString("99021234", HEX));
var macinp = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7", HEX);
macinp = macinp.concat(apdu);
macinp = macinp.concat(new ByteString("800000000000000000", HEX));
var mac = crypto.sign(kmac, Crypto.AES_CMAC, macinp);
apdu = apdu.concat(new ByteString("8E08", HEX));
apdu = apdu.concat(mac.left(8));
apdu = apdu.concat(new ByteString("9000", HEX));

// print("APDU " + apdu);
var r = isc.unwrap(apdu, Card.RPRO|Card.RENC);

// print("Received " + r);

//Test result
assert(r.toString(16) == "414243441234");



//Using AES with SSC_SYNC_ENC_POLICY

var isc = new IsoSecureChannel(crypto, IsoSecureChannel.SSC_SYNC_ENC_POLICY);

var kencval = new ByteString("7CA110454A1A6E570131D9619DC1376E", HEX);
var kenc = new Key();
kenc.setComponent(Key.AES, kencval);

isc.setEncKey(kenc);


var kmacval = new ByteString("0131D9619DC1376E7CA110454A1A6E57", HEX);
var kmac = new Key();
kmac.setComponent(Key.AES, kmacval);

isc.setMacKey(kmac);

var ssc = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6", HEX);
isc.setMACSendSequenceCounter(ssc);
var nextssc = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7", HEX);

var iv = new ByteString("00000000000000000000000000000000", HEX);


//Data | SW1/SW2, RENC|RPRO with SW1/SW2	-&gt; TLenc|TLsw|TLmac|SW1/SW2
//Prepare response from ICC
var apdu = new ByteString("871101", HEX);
var niv = crypto.encrypt(kenc, Crypto.AES_CBC, nextssc, iv);
var enc = crypto.encrypt(kenc, Crypto.AES_CBC, new ByteString(
            "41424344800000000000000000000000", HEX), niv);
apdu = apdu.concat(enc);
apdu = apdu.concat(new ByteString("99021234", HEX));
var macinp = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7", HEX);
macinp = macinp.concat(apdu);
macinp = macinp.concat(new ByteString("800000000000000000", HEX));
var mac = crypto.sign(kmac, Crypto.AES_CMAC, macinp);
apdu = apdu.concat(new ByteString("8E08", HEX));
apdu = apdu.concat(mac.left(8));
apdu = apdu.concat(new ByteString("9000", HEX));

// print("APDU " + apdu);
var r = isc.unwrap(apdu, Card.RPRO|Card.RENC);

// print("Received " + r);

//Test result
assert(r.toString(16) == "414243441234");



//Using AES with default policy and TLV data

var isc = new IsoSecureChannel(crypto);

var kencval = new ByteString("7CA110454A1A6E570131D9619DC1376E", HEX);
var kenc = new Key();
kenc.setComponent(Key.AES, kencval);

isc.setEncKey(kenc);


var kmacval = new ByteString("0131D9619DC1376E7CA110454A1A6E57", HEX);
var kmac = new Key();
kmac.setComponent(Key.AES, kmacval);

isc.setMacKey(kmac);

var ssc = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6", HEX);
isc.setMACSendSequenceCounter(ssc);

var iv = new ByteString("11111111111111111111111111111111", HEX);
isc.setIV(iv);


//Data | SW1/SW2, RENC|RPRO with SW1/SW2	-&gt; TLenc|TLsw|TLmac|SW1/SW2
//Prepare response from ICC
var apdu = new ByteString("8510", HEX);
var enc = crypto.encrypt(kenc, Crypto.AES_CBC, new ByteString(
            "80021234800000000000000000000000", HEX), iv);
apdu = apdu.concat(enc);
apdu = apdu.concat(new ByteString("99021234", HEX));
var macinp = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7", HEX);
macinp = macinp.concat(apdu);
macinp = macinp.concat(new ByteString("80000000000000000000", HEX));
var mac = crypto.sign(kmac, Crypto.AES_CMAC, macinp);
apdu = apdu.concat(new ByteString("8E08", HEX));
apdu = apdu.concat(mac.left(8));
apdu = apdu.concat(new ByteString("9000", HEX));

print("APDU " + apdu);
var r = isc.unwrap(apdu, Card.RPRO|Card.RENC);

print("Received " + r);

//Test result
assert(r.toString(16) == "800212341234");



//Using AES with default policy and plain data

var isc = new IsoSecureChannel(crypto);

var kencval = new ByteString("7CA110454A1A6E570131D9619DC1376E", HEX);
var kenc = new Key();
kenc.setComponent(Key.AES, kencval);

isc.setEncKey(kenc);


var kmacval = new ByteString("0131D9619DC1376E7CA110454A1A6E57", HEX);
var kmac = new Key();
kmac.setComponent(Key.AES, kmacval);

isc.setMacKey(kmac);

var ssc = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF6", HEX);
isc.setMACSendSequenceCounter(ssc);

var iv = new ByteString("11111111111111111111111111111111", HEX);
isc.setIV(iv);


//Data | SW1/SW2, RENC|RPRO with SW1/SW2	-&gt; TLenc|TLsw|TLmac|SW1/SW2
//Prepare response from ICC
var apdu = new ByteString("B304", HEX);
var enc = crypto.encrypt(kenc, Crypto.AES_CBC, new ByteString(
            "80021234800000000000000000000000", HEX), iv);
apdu = apdu.concat(new ByteString("80021234", HEX));
apdu = apdu.concat(new ByteString("99021234", HEX));
var macinp = new ByteString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7", HEX);
macinp = macinp.concat(apdu);
macinp = macinp.concat(new ByteString("800000000000", HEX));
var mac = crypto.sign(kmac, Crypto.AES_CMAC, macinp);
apdu = apdu.concat(new ByteString("8E08", HEX));
apdu = apdu.concat(mac.left(8));
apdu = apdu.concat(new ByteString("9000", HEX));

print("APDU " + apdu);
var r = isc.unwrap(apdu, Card.RPRO);

print("Received " + r);

//Test result
assert(r.toString(16) == "800212341234");



</pre>
<h2 id="setCRT">setCRT()</h2>
<h3>Prototype</h3>
<p class="signature">void setCRT(ByteString crt)</p>
<h3>Description</h3>
            
<p>Set a cryptographic reference template to be included in the body of the
               command APDU.</p>
            
<p>The CRT is included in the MAC if the tag is odd.</p>
        
<h3>Arguments</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="100">
<col>
</colgroup>
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr>
<tr>
<td><code><a href="bytestring.html">ByteString</a></code></td><td>crt</td><td>The cryptographic reference template or null</td>
</tr>
</table>
<h3>Return</h3>
<table>
<colgroup>
<col width="100">
<col>
</colgroup>
<tr>
<td><code>void</code></td><td>The method does not return a value</td>
</tr>
</table>
<h3>Exceptions</h3>
<table class="content">
<colgroup>
<col width="100">
<col width="200">
<col>
</colgroup>
<tr>
<th>Name</th><th>Value</th><th>Description</th>
</tr>
<tr>
<td>GPError</td><td>GPError.ARGUMENTS_MISSING</td><td>Too few arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_ARGUMENTS</td><td>Too many arguments in call</td>
</tr>
<tr>
<td>GPError</td><td>GPError.INVALID_TYPE</td><td>The argument must be of type ByteString</td>
</tr>
</table>
<h3>Example</h3>
<pre>

var isc = new IsoSecureChannel(crypto);

var kencval = new ByteString("7CA110454A1A6E570131D961" +
                             "9DC1376E4A1A6E570131D961", HEX);
var kenc = new Key();
kenc.setComponent(Key.DES, kencval);
isc.setEncKey(kenc);

var kmacval = new ByteString("0131D9619DC1376E7CA11045" +
                             "4A1A6E579DC1376E7CA11045", HEX);
var kmac = new Key();
kmac.setComponent(Key.DES, kmacval);
isc.setMacKey(kmac);

var iv = new ByteString("1111111111111111", HEX);
isc.setIV(iv);

var crt = new ByteString("B803830103", HEX);
isc.setCRT(crt);

var ssc = new ByteString("FFFFFFFFFFFFFFFD", HEX);
isc.setMACSendSequenceCounter(ssc);

//Case 4s Command APDU CLA=00 INS=10 P1=20 P2=30 Lc=04 Data=41424344 Le=80
var apdu = new ByteString("00102030044142434480", HEX);

// Case 4s Plain		-&gt; CLA'|INS|P1|P2|Lc'|TLplain|TLle|00
var r = isc.wrap(apdu, 0);

// Test result
assert(r.toString(16) == "081020300EB80383010380044142434496018000");
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFFD");



// Case 4s CENC		-&gt; CLA'|INS|P1|P2|Lc'|TLenc|TLle|00
var r = isc.wrap(apdu, Card.CENC);

// Test result
var exp = new ByteString("0810203013B803830103860901", HEX);
var enc = crypto.encrypt(kenc, Crypto.DES_CBC, new ByteString(
            "4142434480000000", HEX), iv);
exp = exp.concat(enc);
exp = exp.concat(new ByteString("96018000", HEX));
assert(r.equals(exp));
assert(isc.sendSequenceCounter.toString(16) == "FFFFFFFFFFFFFFFE");



// Case 4s CPRO		-&gt; CLA'|INS|P1|P2|Lc'|TLplain|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CPRO);

// Test result
var exp = new ByteString("0C10203018B8038301038104414243449701808E08", HEX);
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, new ByteString(
            "FFFFFFFFFFFFFFFF0C10203080000000" +
            "81044142434497018080000000000000", HEX));
exp = exp.concat(mac).concat(new ByteString("00", HEX));
assert(r.equals(exp));


var crt = new ByteString("B903830103", HEX);
isc.setCRT(crt);

// Case 4s CENC|CPRO	-&gt; CLA'|INS|P1|P2|Lc'|TLenc|TLle|TLmac|00
var r = isc.wrap(apdu, Card.CENC|Card.CPRO);

// Test result
var exp = new ByteString("0C1020301DB903830103870901", HEX);
var enc = crypto.encrypt(kenc, Crypto.DES_CBC, new ByteString(
            "4142434480000000", HEX), iv);
exp = exp.concat(enc);
exp = exp.concat(new ByteString("9701808E08", HEX));
var macinp = new ByteString("00000000000000000C10203080000000B903830103870901", HEX);
macinp = macinp.concat(enc);
macinp = macinp.concat(new ByteString("970180", HEX));
macinp = macinp.concat(new ByteString("8000000000", HEX));
var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, macinp);
exp = exp.concat(mac).concat(new ByteString("00", HEX));

// print("Expected " + exp);
// print("Received " + r);

assert(r.equals(exp));


</pre>
                    <!-- #EndEditable -->
<br>
<p class="copyright">&copy; Copyright 2003 - 2010 <a href="http://www.cardcontact.de">CardContact</a>
Software & System Consulting, Minden, Germany</p>
</div>

</body>
</html><!-- #EndTemplate -->
        
